{"version":3,"file":"devlevel.min.js","sources":["../src/index.js"],"sourcesContent":["const toStr = Object.prototype.toString\r\nconst conditions = {\r\n\tfinite(o) {\r\n\t\treturn o === o && o !== Infinity && toStr.call(o) === '[object Number]'\r\n\t}\r\n}\r\n\r\nconst byteArray = ['Uint8Array', 'Int8Array']\r\nconst shortArray = ['Uint16Array', 'Int16Array']\r\nconst intArray = ['Uint32Array', 'Int32Array']\r\nconst floatArray = ['Float32Array', 'Float64Array']\r\nconst arrayBuffer = 'ArrayBuffer'\r\nconst typedArrays = byteArray.concat(shortArray).concat(intArray).concat(floatArray).concat(arrayBuffer)\r\n\r\ncon(isStr, 'bool', 'Boolean')\r\ncon(isStr, 'num', 'Number')\r\ncon(isStr, 'str', 'String')\r\ncon(isType, 'fn', 'function')\r\ncon(isStr, 'date', 'Date')\r\ncon(isStr, 'array', 'Array')\r\nfor (let i = 0; i < typedArrays.length; i++)\r\n\tcon(isStr, typedArrays[i].replace(/^[a-zA-Z]/, o => o.toLowerCase()), typedArrays[i])\r\ncon(isStr, 'byteArray', byteArray)\r\ncon(isStr, 'shortArray', shortArray)\r\ncon(isStr, 'intArray', intArray)\r\ncon(isStr, 'floatArray', floatArray)\r\ncon(isStr, 'arrayBuffer', arrayBuffer)\r\ncon(isStr, 'typedArray', typedArrays)\r\ncon(isStr, 'array', 'Array')\r\ncon(isStr, 'array', 'Array')\r\ncon(isStr, 'reg', 'RegExp')\r\ncon(isStr, 'obj', 'Object')\r\ncon(isStr, 'err', 'Error')\r\ncon(isStr, 'arrayLike', ['Array', 'Arguments', 'NodeList'].concat(typedArrays))\r\ncon(isValue, 'nil', ['undefined', 'null'])\r\ncon(isValue, 'nul', 'null')\r\ncon(isValue, 'undef', 'undefined', 0, 0)\r\ncon(isValue, 'def', 'undefined', 1, 0)\r\ncon(isValue, 'NaN', 'o', 1)\r\ncon(isValue, 'infinite', 'Infinity')\r\ncon((v, isNot) => isExpr(['a', 'b'], `return ${isNot ? '!':''}(a===b||(a!==a&&b!==b));`), 'eq')\r\n\r\nfunction con(is, name, value, isNot = 0, addNot = 1) {\r\n\tlet fn = conditions[name] = is(value, isNot)\r\n\tfn.__name__ = name\r\n\tif (addNot) {\r\n\t\tname = 'not' + name.replace(/^[a-zA-Z]/, o => o.toUpperCase())\r\n\t\tfn = conditions[name] = is(value, !isNot)\r\n\t\tfn.__name__ = name\r\n\t}\r\n}\r\n\r\nfunction isType(t, isNot) {\r\n\treturn isIn('o', 'typeof o', t, isNot, t => `'${t}'`)\r\n}\r\n\r\nfunction isStr(s, isNot) {\r\n\treturn isIn('o', 'Object.prototype.toString.call(o)', s, isNot, s => `'[object ${s}]'`)\r\n}\r\n\r\nfunction isValue(v, isNot) {\r\n\treturn isIn('o', 'o', v, isNot)\r\n}\r\n\r\nfunction isIn(params, condition, cases, isNot, valueHandle) {\r\n\tif (!(cases instanceof Array)) cases = [cases]\r\n\tconst len = cases.length\r\n\tif (valueHandle) {\r\n\t\tvar i = len,\r\n\t\t\tarr = new Array(len)\r\n\t\twhile (i--) arr[i] = valueHandle(cases[i])\r\n\t\tcases = arr\r\n\t}\r\n\treturn isExpr(params, len > 1 ? `switch(${condition}){\r\ncase ${cases.join(':\\n\\t\\tcase ')}:\r\nreturn ${!isNot};\r\ndefault:\r\nreturn ${!!isNot};\r\n}` : `return (${condition})${isNot ? '!': '='}==${cases[0]};`)\r\n}\r\n\r\n\r\nfunction isExpr(params, expr) {\r\n\tif (!(params instanceof Array))\r\n\t\tparams = [params]\r\n\tconst fn = Function.apply(Function, params.concat(expr.apply ? expr(params) : expr))\r\n\tfn.params = params\r\n\treturn fn\r\n}\r\n\r\nfunction _if(condition, callback, isNot) {\r\n\tconst params = condition.params || ['o']\r\n\treturn new Function('condition', 'callback', 'slice', `return function(${params.join(',')}){\r\nif(${isNot ? '!' : ''}condition(${params.join(',')}))\r\n    callback(slice(arguments, ${params.length}));\r\n}`)(condition, callback, sliceArgs)\r\n}\r\n\r\nfunction assignCons(obj, callback, isNot) {\r\n\tfor (let name in conditions)\r\n\t\tobj[name] = _if(conditions[name], callback, isNot)\r\n}\r\n\r\nfunction callBy(condition, cb) {\r\n\tswitch (arguments.length) {\r\n\t\tcase 0:\r\n\t\t\treturn\r\n\t\tcase 1:\r\n\t\t\tcondition()\r\n\t\t\treturn\r\n\t\tdefault:\r\n\t\t\tcondition && cb()\r\n\t}\r\n}\r\nexport function exception(error) {\r\n\tif (typeof error === 'function')\r\n\t\terror = error()\r\n\tif (error instanceof Error) throw error\r\n\tthrow new Error(error)\r\n}\r\n\r\nexport function assert(condition, error) {\r\n\tif (!condition) exception(error)\r\n}\r\nassignCons(assert, (args) => exception(args[0]), 1)\r\nassert.by = callBy\r\n\r\n\r\nlet currentLevel = 1\r\nconst logs = []\r\nconst logMap = {}\r\n\r\nexport const debug = createLog('debug', 0)\r\nexport const info = createLog('info', 1)\r\nexport const warn = createLog('warn', 2)\r\nexport const error = createLog('error', 3)\r\n\r\nif (!console) console = {\r\n\tlog() {}\r\n}\r\n\r\nfunction createLog(name, level) {\r\n\tif (!console[name]) console[name] = console.log\r\n\r\n\tfunction print(args) {\r\n\t\targs.length && console[name].apply(console, [mark].concat(args))\r\n\t}\r\n\r\n\tfunction log() {\r\n\t\tprint(arguments)\r\n\t}\r\n\tlog.level = level\r\n\tlog.methods = getLogMethods(name, print)\r\n\tlogs[name] = log\r\n\tlogMap[level] = log\r\n\treturn bindLog(log)\r\n}\r\n\r\nfunction getLogMethods(name, print) {\r\n\tconst mark = `[${name}]: `\r\n\treturn assignCons({\r\n\t\tby: callBy,\r\n\t\twhen(condition) {\r\n\t\t\tcondition && this.print(sliceArgs(arguments, 1))\r\n\t\t},\r\n\t\tprint\r\n\t}, print)\r\n}\r\n\r\nfunction bindLog(log) {\r\n\tconst {\r\n\t\tlevel,\r\n\t\tmethods\r\n\t} = log\r\n\tfor (let method in methods) {\r\n\t\tlog[method] = level < currentLevel ? empty : methods[method]\r\n\t}\r\n\treturn log\r\n}\r\n\r\nexport function setLogLevel(level) {\r\n\tconst log = logMap[level]\r\n\tif (log) {\r\n\t\tconst level = log.level\r\n\t\tconst min = Math.min(level, currentLevel)\r\n\t\tconst max = Math.min(level, currentLevel)\r\n\t\tfor (let i = min; i <= max; i++) {\r\n\t\t\tbindLog(logs[i])\r\n\t\t}\r\n\t\tcurrentLevel = level\r\n\t}\r\n}\r\n\r\nfunction sliceArgs(args, offset) {\r\n\tlet len = args.length\r\n\tconst arr = new Array(len - offset)\r\n\twhile (len-- > offset)\r\n\t\tarr[len - offset] = args[len]\r\n\treturn arr\r\n}"],"names":["toStr","Object","prototype","toString","conditions","o","Infinity","call","byteArray","shortArray","intArray","floatArray","arrayBuffer","typedArrays","concat","con","isStr","t","isNot","isIn","i","length","replace","toLowerCase","isValue","v","isExpr","is","name","value","addNot","fn","__name__","toUpperCase","s","params","condition","cases","valueHandle","Array","len","arr","join","expr","Function","apply","_if","callback","sliceArgs","assignCons","obj","callBy","cb","arguments","exception","error","Error","assert","args","by","currentLevel","logs","logMap","debug","createLog","info","warn","console","level","log","print","mark","methods","this","bindLog","method","empty","offset","min","Math","max"],"mappings":"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"}